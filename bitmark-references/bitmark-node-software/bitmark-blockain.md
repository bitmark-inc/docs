# Blockchain

## Block

Block is a bunch of transactions that have been added to blockchain. A bitmark block contains data as follows:

| size (bytes) | data                                                           |
|--------------+----------------------------------------------------------------|
|            2 | block version number                                           |
|            2 | transaction count inside the block                             |
|            8 | block number (block height)                                    |
|           32 | argon2 hash of previous block header                           |
|           32 | sha3 hash of all transactions in the block (merkle root)       |
|            8 | timestamp of block generation time, since 1970-01-01T00:00 UTC |
|            8 | current difficulty in compact mode                             |
|            8 | number to make hash meets difficulty                           |
|   ... to end | transactions                                                   |

Different types of transaction includes different lenegh and content inside.

### Block Verification

When a block is received, following checks will be made:

1. Length of all parts inside a block should match
1. Incoming block version number should be equal or largen than current block version number
1. Incoming block height is 1 ahead of current block height
1. Incoming block contans at least 1 transaction, at most 9999 transactions inside
1. Incoming block generation time no further than 5 minutes after received time
1. Incoming block generation time can not be larger then 10 minutes compares to current block generation time
1. Incoming block generation time within specific range
1. Incoming block difficulty is same as current difficulty
1. Incoming block hash meets difficulty criteria
1. Incoming block's previous block hash same as current block hash
1. Incoming transaction fits each type's format and length
1. Incoming transaction owner ownership is valid
1. Incoming transaction payment is valid
1. Incoming block's sha3 of all transactions inside is valid

After a block is verified, a node stores that block into its internal
database (leveldb), then node broadcast this newly saved block to all connected
nodes. When other node receives the broadcast of a block, each node
verifies block correctness by rules described above.

### Block Synchronization

Bitmark blockchain uses both proof-of-work (PoW) and majority votes to
choose blocks.

#### Proof of Work

A proof of work is a piece of data which is difficult (costly, time-consuming) to produce but easy for others to verify and which satisfies certain requirements. Producing a proof of work can be a random process with low probability so that a lot of trial and error is required on average before a valid proof of work is generated. Bitcoin uses the Hashcash proof of work system.

In order for a block to be accepted by network participants, miners must complete a proof of work which covers all of the data in the block. The difficulty of this work is adjusted so as to limit the rate at which new blocks can be generated by the network to one every 2 minutes. Due to the very low probability of successful generation, this makes it unpredictable which worker computer in the network will be able to generate the next block.

For a block to be valid it must hash to a value less than the current target; this means that each block indicates that work has been done generating it. Each block contains the hash of the preceding block, thus each block has a chain of blocks that together contain a large amount of work. Changing a block (which can only be done by making a new block containing the same predecessor) requires regenerating all successors and redoing the work they contain. This protects the block chain from tampering.

Bitmark uses [argon2](https://en.wikipedia.org/wiki/Argon2) to hash whole block.

#### Majority Votes

When deciding next block, every node considers decisions from other nodes, the most block selected by other nodes will be chosen. Every 30 seconds, a node asks its connected nodes for their block hash and block height. This information will be used to determine majority votes. For a specific chain, same block hegith exists same block hash, so a node can know itself status by this information.

Some conditionas could happen when deciding block:

1. majority votes exists

| Node | Block Height | Block Hash |
|------+--------------+------------|
| A    |         1000 | abcdefg    |
| B    |         1000 | abcdefg    |
| C    |         1000 | gfedcba    |
| D    |         1000 | abcdefg    |
| E    |         1000 | abcdefg    |
| F    |         1000 | abcdefg    |

In this example, node C resides on different chain than other (because
its block hash is different from others at same block height).

For node A, when it asks other nodes situation with following response
(assumes all nodes are connected):

| Count | Block Height | Block Hash |
|-------+--------------+------------|
| 4     |         1000 | abcdefg    |
| 1     |         1000 | gfedcba    |

So node A will keep choose chain that has hash abcdefg on block
height 1000.

For node C, when it asks other nodes situation with following response
(assumes all nodes are connectd):

| Count | Block Height | Block Hash |
|-------+--------------+------------|
| 5     |         1000 | abcdefg    |

So node C will choose chain that has hash abcdefg on block height
1000, which means it selft will sync to other nodes.

1. several groups with same votes

| Node | Block Height | Block Hash |
|------+--------------+------------|
| A    |         1000 | abcdefg    |
| B    |         1000 | abcdefg    |
| C    |         1000 | abcdefg    |
| D    |         1000 | gfedcba    |
| E    |         1000 | gfedcba    |
| F    |         1000 | gfedcba    |

In thie example, two groups of nodes with equal votes. If there's a
new node G connect into network, the response from G as follows:

| Count | Block Height | Block Hash |
|-------+--------------+------------|
| 3     |         1000 | abcdefg    |
| 3     |         1000 | gfedcba    |

So it's a tie in this situation, when this situation happens, node G will
check hash value of two chains: abcdefg & gfedcba. To which chain
has smaller value will be chosen. Since block hash is stored in little
endian, so block hash of gfedcba is choosen by node G. As node G
connects to network and chooses chain gfedcba, separated groups no
longer in tie and eventuall, chain gfedcba dominates network.
