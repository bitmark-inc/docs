---
title: Block Verification and Synchronization
keywords: blockchain, verification, sync, synchronization
last_updated: 
sidebar: mydoc_sidebar
permalink: block-verification-and-synchronization.html
folder: bitmark-references/bitmark-node-software
---

# Block Verification and Synchronization

## Bitmark Block

Block is a bunch of transactions that have been added to blockchain. A bitmark block contains data as follows:

```
  size (bytes)                                  data
 -------------- -------------------------------------------------------------------------
   2             block version number
   2             transaction count inside the block
   8             block number (block height)
  32             argon2 hash of previous block header
  32             sha3 hash of all transactions in the block (merkle root)
   8             timestamp of block generation time, seconds since 1970-01-01T00:00:00 UTC
   8             current difficulty in compact mode
   8             number to make hash meets difficulty
   ... to end    transactions

```

## Different types of transactions

Different types of transactions include different lengths and content inside.

For example, consider the block header string of:

```
05008300a1820000000000001e886357e769dab9c5f9b68a9101c13888a8b9aaf2bc21ff3aa2b78fbac114002684b245a1f51f54677770530032471f0ec4c36ffae5f14001eb15f42082e31becc1895d00000000d3dbb256c7042f00deb653d83b4a0bc7
```

Remember that a byte is made up of two hexadecimal characters. The header string could thus be broken up as follows, using the byte counts above:

```
0500/8300/a182000000000000/1e886357e769dab9c5f9b68a9101c13888a8b9aaf2bc21ff3aa2b78fbac11400/2684b245a1f51f54677770530032471f0ec4c36ffae5f14001eb15f42082e31b/ecc1895d00000000/d3dbb256c7042f00/deb653d83b4a0bc7
```

Also remember that each element has its bytes reversed because it's encoded in little endian. The various fields are thus decoded as follows:

```
Version:0x5,
TransactionCount:0x83,
Number:0x82a1,
PreviousBlock: 0x0014c1ba8fb7a23aff21bcf2aab9a88838c101918ab6f9c5b9da69e75763881e,
MerkleRoot: 0x1be38220f415eb0140f1e5fa6fc3c40e1f47320053707767541ff5a145b28426,
Timestamp:0x5d89c1ec,
Difficulty:00978263ab596de9800000000000000000000000000000000000000000000000,
Nonce:0xc70b4a3bd853b6de
```

## Block Validation

When a block is received, the following checks will be made:

1. Length of all parts inside a block should match
1. Incoming block version number should be equal or largen than current block version number
1. Incoming block height is 1 ahead of current block height
1. Incoming block contans at least 1 transaction, at most 9999 transactions inside
1. Incoming block generation time, compared to received time, should within 5 minutes
1. Incoming block generation time can not be larger then 10 minutes compares to current block generation time
1. Incoming block generation time within specific range
1. Incoming block difficulty is same as current difficulty
1. Incoming block hash meets difficulty criteria
1. Incoming block's previous block hash same as current block hash
1. Incoming transaction fits each type's format and length
1. Incoming transaction owner ownership is valid
1. Incoming transaction payment is valid
1. Incoming block's sha3 of all transactions inside is valid

After a block is validated, a node stores that block into its internal
database (leveldb), then node broadcast this newly saved block to all connected
nodes. When other node receives the broadcast of a block, each node
validates block correctness by rules described above.

## Block Synchronization

Bitmark blockchain uses both proof-of-work (PoW) and majority votes to
choose blocks.

### Proof of Work

Proof of work is the traditional method of Sybil defense on a blockchain, used by Bitcoin and (at the moment) by Ethereum. Every participant is given the opportunity to solve a math problem. Whoever manages to do so is allowed to propose a block for the blockchain, contributing to the consensus and the growth of the ledger. Sybil defense is provided by the fact that itâ€™s very hard to make these calculations, and so has real costs in energy.

In order for a block to be accepted by network participants, miners must complete a proof of work which covers all of the data in the block. The difficulty of this work is adjusted so as to limit the rate at which new blocks can be generated by the network to one every 2 minutes. Due to the very low probability of successful generation, this makes it unpredictable which worker computer in the network will be able to generate the next block.

For a block to be valid it must hash to a value less than the current target; this means that each block indicates that work has been done generating it. Each block contains the hash of the preceding block, thus each block has a chain of blocks that together contain a large amount of work. Changing a block (which can only be done by making a new block containing the same predecessor) requires regenerating all successors and redoing the work they contain. This protects the block chain from tampering.

Bitmark uses [argon2](https://en.wikipedia.org/wiki/Argon2) to hash the block header; remaining data is covered by having the Merkle Tree Root hash as part of the header. If transactions are different or in a different order the the Merkle Root has will not match and the block will be rejected.

### Majority Votes

When deciding next block, every node considers decisions from other nodes, the block selected by the most other nodes will be chosen. Every 30 seconds, a node asks its connected nodes for their block hash and block height. This information will be used to determine the main chain based on majority vote. For different chains, same block hegith with different block hash, so a node can distinguish a fork chain by information of block hash on specific block number.

Some conditionas could happen when deciding block:

1. majority votes exists

```
  Node    Block Height    Block Hash
 ------  --------------  ------------
  1       1000            abcdefg
  2       1000            abcdefg
  3       1000            gfedcba
  4       1000            abcdefg
  5       1000            abcdefg
  6       1000            abcdefg
```

In this example, node-3 resides on different chain than other (because
its block hash is different from others at same block height).

For node-1, when it asks other nodes situation with following response
(assumes all nodes are connected):

```
  Count    Block Height    Block Hash
 -------  --------------  ------------
  4        1000            abcdefg
  1        1000            gfedcba
```

So node-1 will keep choose chain that has hash abcdefg on block
height 1000.

For node-3, when it asks other nodes situation with following response
(assumes all nodes are connectd):

```
  Count   Block Height   Block Hash
 ------- -------------- ------------
  5       1000           abcdefg
```

So node-3 will choose chain that has hash abcdefg on block height
1000, which means it selft will sync to other nodes.

1. several groups with same votes
```
  Node   Block Height   Block Hash
 ------ -------------- ------------
  A      1000           abcdefg
  B      1000           abcdefg
  C      1000           abcdefg
  D      1000           gfedcba
  E      1000           gfedcba
  F      1000           gfedcba
```

In thie example, two groups of nodes with equal votes. If there's a
new node-7 connect into network, the response from node-7 as follows:

```
  Count   Block Height   Block Hash
 ------- -------------- ------------
  3       1000           abcdefg
  3       1000           gfedcba
```

So it's a tie in this situation, when this situation happens, node-7 will
check hash value of two chains: abcdefg & gfedcba. To which chain
has smaller value will be chosen. Since block hash is stored in little
endian, so block hash of gfedcba is choosen by node-7. As node-7
connects to network and chooses chain gfedcba, separated groups no
longer in tie and eventuall, chain gfedcba dominates network.

Even if there's no new node connects to the network, as long as some
node founds all other connected remote nodes separates into groups,
the node will also use hash value to decide which chain should be
adopted.
