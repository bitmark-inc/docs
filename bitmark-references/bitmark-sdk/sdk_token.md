# SDK Token

New SDK token lets you aquire the token dynamically from your backend side instead of hardcoding in your app.  
It will avoid leaking your api token through reverse engineering the app.

## Technical overview
This mechanism leverages [JWT](https://jwt.io) to issue a token from your backend side. The token will be transferred to the app as SDK token.  
Bitmark system will validate the token against JWT format, and the public key of JWT that has been registered by your backend side.

![Bitmark authentication diagram](images/authentication_flowchart.png)

## Terms
These are terms will be used to describe the flow:
* Client certificate: A pem file, will be generated and held by enterprise's server side securely. Use to issue a Bitmark SDK token to use with Bitmark SDK.
* Client public key: Public key associates with client certificate.
* Client ID: A base64 encoded string, generate from the client public key.

## Flow
### Parties
1. Bitmark API
3. Backend server: Take responsibility to **store Client certificate**
4. Mobile app / client: Using Bitmark SDK.
5. Bitmark SDK
6. SDK key generator: A CLI to generate client certificate and client public key. Use client public key submits to *Bitmark Inc.* to register a client id.

### Usage
1. Download [CLI app](https://github.com/bitmark-inc/sdk-key-generator), then run to generate a RSA 2048 byte length keypair. The keypair will be serialized in PKCS1 format. Private key will be saved as pem file. Public key will be encoded with base64 standard format and print out to the console.
2. Copy that public key, and send to *Bitmark Inc.* to register a client id. Client ID is computed by hashing with MD5, then encoded with base64 standard format.
3. Save the Client certificate pem file in a safe place on their server side.
4. Generate Bitmark SDK from their server side. The sample code for doing that is provided in [the CLI app](https://github.com/bitmark-inc/sdk-key-generator/blob/develop/main.go#L47).
5. On mobile app, it needs to get Bitmark SDK token from server side, fills it to Bitmark SDK and use.

### How it works

#### Client ID
Client ID identifies the public key of Client certificate was using to sign JWT token, so from Bitmark API side we can verify it.  
**How to calculate client id**
``` go
// read data from client certificate (pem file)
jwtPemByte, _ := ioutil.ReadFile(pemfile)

// load private key
jwtPrivateKey, _ := jwt.ParseRSAPrivateKeyFromPEM(jwtPemByte)

// load public key
pubkey := x509.MarshalPKCS1PublicKey(&jwtPrivateKey.PublicKey)

// calculate md5 sum
pubkeyMd5sum := md5.Sum(pubkey)

// clientID is base64 encoded of pubkeyMd5sum
clientID := base64.StdEncoding.EncodeToString(pubkeyMd5sum[:])
```

#### Bitmark SDK token
Bitmark SDK token is a [JWT token](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html) that uses RS256 method.  
Information in this token:
* alg: RS256
* iss: [Client ID](#client-id)
* sub: Bitmark Account that is granted by this token
* nbf: Not before date
* exp: Expiry date (server side defines the value of expiry date as they want)
This JWT token needs to be signed by Client certificate file that has been generated by CLI app.  

#### API requests
All requests to API v5 require Authorization header:  
```Authorization: Bearer <SDK_TOKEN>```